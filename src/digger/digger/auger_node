# This ROS 2 node contains the code for the auger subsystem of the robot
import time

# Import the ROS 2 Python module
import rclpy
from rclpy.node import Node
from rclpy.executors import MultiThreadedExecutor
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup

# Import ROS 2 formatted message types
from std_msgs.msg import Float32, Float32MultiArray

# Import custom ROS 2 interfaces
from rovr_interfaces.srv import MotorCommandSet, MotorCommandGet
from rovr_interfaces.srv import SetPower, SetPosition
from rovr_interfaces.msg import Potentiometers
from std_srvs.srv import Trigger

class Auger(Node):
    def __init__(self):
        "Initialize the ROS 2 Auger node"
        super().__init__('auger')

        self.service_cb_group = MutuallyExclusiveCallbackGroup()
        self.stop_cb_group = MutuallyExclusiveCallbackGroup()

        #TODO Define service clients here
        self.cli_tilt_actuator = self.create_client(MotorCommandSet, "actuator_tilt/set")
        self.cli_push_actuator = self.create_client(MotorCommandSet, "actuator_push/set")
        self.cli_spin_motor = self.create_client(MotorCommandSet, "motor_spin/set")

        #Define parameters here
        self.declare_parameter("push_position_limit", 1.0)
        self.declare_parameter("spin_velocity", 0.0)



        #Local variables here
        self.tilt_limit = self.get_parameter("tilt_limit").value
        self.push_position_limit = self.get_parameter("push_position_limit").value
        self.spin_velocity = self.get_parameter("spin_velocity").value



        #TODO Define services (methods callable from the outside) here
        self.srv_set_tilt_position = self.create_service(
            SetPosition, "actuator_tilt/setPosition", self.set_tilt_position_callback, callback_group=self.service_cb_group
        )
        self.srv_stop_tilt = self.create_service(
            Trigger, "actuator_tilt/stop", self.stop_tilt_callback, callback_group=self.stop_cb_group
        )

        self.srv_set_push_position = self.create_service(
            SetPosition, "actuator_push/setPosition", self.set_push_position_callback, callback_group=self.service_cb_group
        )
        self.srv_stop_push = self.create_service(
            Trigger, "actuator_push/stop", self.stop_push_callback, callback_group=self.stop_cb_group
        )

        self.srv_set_angular_velocity = self.create_service(
            SetPower, "motor_spin/setPower", self.set_auger_spin_velocity_callback, callback_group=self.service_cb_group
        )
       
        #TODO Define subscribers here - need to subscribe to potentiometer readings?

        #TODO Define publishers here 



        self.get_logger().info("tilt_limit is set to: " + str(self.tilt_limit))
        self.get_logger().info("push_position_limit is set to: " + str(self.push_position_limit))
        self.get_logger().info("spin_velocity is set to: " + str(self.spin_velocity))



    #Define subsystem methods here

    #TODO set tilt position - is this really an angle? More likely a max position.
    #TODO shouldn't we rather have just the two options exctract fully and retract fully? - introduce two loc vals for max and min position?
    def set_actuator_tilt_position(self, tilt: bool) -> bool:
        """ Set the auger tilt position of the actuator."""
        self.get_logger().info("The : " + str(tilt))

        self.cli_tilt_actuator.call_async(
            MotorCommandSet.Request(
                type="position",
                value=float(angle),
            )
        )
        return True
    

    def stop_actuator_tilt(self) -> bool:
        """ Stop the auger angular position of the auger motor."""
        self.cli_tilt_actuator.call_async(
            MotorCommandSet.Request(
                type="duty_cycle",
                value=0.0,
            )
        )
        return True


    #TODO set position of the actuator that pushes the auger into the ground
    def set_actuator_push_position(self, position: float, power_limit: float) -> bool:
        """ Set the target position of the linear actuator that pushes the auger into the ground."""
        self.get_logger().info("Setting actuator position to: " + str(position))
        if position <= self.push_position_limit:
            self.target_actuator_position = position
            self.cli_push_actuator.call_async(
            MotorCommandSet.Request(
                type="position",
                value=float(position),
            )
        )
            return True
        return False


    #TODO get position linear actuator
    def get_actuator_push_position(self) -> float:
        """ Get the position of the linear actuator that pushes the auger into the ground."""
        return 0.0

    def stop_actuator_push(self) -> bool:
        """ Stop the linear actuator that pushes the auger into the ground."""
        self.cli_push_actuator.call_async(
            MotorCommandSet.Request(
                type="duty_cycle",
                value=0.0,
            )
        )
        return True


    #TODO set auger spin velocity
    def set_auger_spin_velocity(self, velocity: float) -> bool:
        """ Set the auger spin velocity of the auger motor."""
        self.get_logger().info("Setting auger spin velocity to: " + str(velocity))
        self.target_spin_velocity = velocity
        self.cli_spin_motor.call_async(
            MotorCommandSet.Request(
                type="velocity",
                value=float(velocity),
            )
        )
        return True
    

    #TODO auger spin velocity
    def get_auger_spin_velocity(self) -> float:
        """ Get the auger spin velocity of the auger motor."""
        return 0.0
    







    #TODO  Define service callback methods here
    def set_tilt_position_callback(self, request, response):
        """This service request sets position of the angular motor."""
        self.set_actuator_tilt_position(request.position)
        response.success = True
        return response
    
    def stop_tilt_callback(self, request, response):
        """This service request stops the angular motor."""
        self.stop_actuator_tilt()
        response.success = True
        return response




    def set_push_position_callback(self, request, response):
        """This service request sets position of the actuator that pushes the auger into the ground."""
        self.set_actuator_push_position(request.position, request.power_limit)
        response.success = True
        return response
    
    def stop_push_callback(self, request, response):
        """This service request stops the actuator that pushes the auger into the ground."""
        self.stop_actuator_push()
        response.success = True
        return response
    



    def set_auger_spin_velocity_callback(self, request, response):
        """This service request sets the turn velocity of the auger"""
        self.set_auger_spin_velocity(request.power)
        response.success = True
        return response
    
    
        





def main(args=None):
    """The main function."""
    rclpy.init(args=args)

    node = Auger()
    executor = MultiThreadedExecutor()
    executor.add_node(node)

    node.get_logger().info("Initializing the Auger subsystem!")
    try:
    
        executor.spin()
    #TODO this exception needed? Could this ever happen?
    except KeyboardInterrupt:
        node.get_logger().info("Shutting down the Auger subsystem.")
    finally:
        node.destroy_node()
    
    
    
    rclpy.shutdown()


# This code does NOT run if this file is imported as a module
if __name__ == "__main__":
    main()
